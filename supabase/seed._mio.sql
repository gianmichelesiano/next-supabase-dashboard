-- Config
ALTER ROLE authenticator SET pgrst.db_aggregates_enabled = 'true';
NOTIFY pgrst, 'reload config';

-- Extensions
create extension if not exists pgcrypto schema extensions;
create extension if not exists moddatetime schema extensions;

-- Storage setup
delete from storage.objects where bucket_id = 'gare';
delete from storage.buckets where id = 'gare';

drop policy if exists "Public access for all users" on storage.objects;
drop policy if exists "User can upload in their own folders" on storage.objects;
drop policy if exists "User can update their own objects" on storage.objects;
drop policy if exists "User can delete their own objects" on storage.objects;

insert into storage.buckets (id, name, public) values ('gare', 'gare', true);

create policy "Public access for all users" on storage.objects
  for select to authenticated, anon using (bucket_id = 'gare');
create policy "User can upload in their own folders" on storage.objects
  for insert to authenticated with check (bucket_id = 'gare' and (storage.foldername(name))[1] = (select auth.uid()::text));
create policy "User can update their own objects" on storage.objects
  for update to authenticated using (owner_id = (select auth.uid()::text));
create policy "User can delete their own objects" on storage.objects
  for delete to authenticated using (owner_id = (select auth.uid()::text));
-- Create core tables first
create table users (
  id uuid not null references auth.users on delete cascade primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  deleted_at timestamptz,
  email varchar(255),
  full_name text,
  first_name text,
  last_name text,
  age integer,
  avatar_url text,
  website text,
  bio text,
  username text not null,
  username_changed_at timestamptz,
  has_set_password boolean default false not null,
  is_ban boolean default false not null,
  banned_until timestamptz,
  role text default 'guest'::text not null,
  role_changed_at timestamptz,
  plan text default 'free'::text not null,
  plan_changed_at timestamptz,
  unique (username)
);

create table role_permissions (
  id bigint generated by default as identity primary key,
  role text not null,
  permission text not null,
  unique (role, permission)
);

create table emails (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  user_id uuid references users(id) on delete cascade not null,
  email varchar(255) not null,
  email_confirmed_at timestamptz,
  unique (user_id, email)
);

create table notifications (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  user_id uuid references users(id) on delete cascade not null,
  marketing_emails boolean default false not null,
  security_emails boolean default true not null
);

create table posts (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  deleted_at timestamptz,
  date timestamptz,
  user_id uuid references users(id) on delete cascade not null,
  type text default 'post'::text not null,
  status text default 'draft'::text not null,
  password varchar(255),
  title text,
  slug text,
  description text,
  keywords text,
  content text,
  thumbnail_url text,
  permalink text,
  is_ban boolean default false not null,
  banned_until timestamptz
);

create table postmeta (
  id bigint generated by default as identity primary key,
  post_id bigint references posts(id) on delete cascade not null,
  meta_key varchar(255) not null,
  meta_value text,
  unique(post_id, meta_key)
);

create table favorites (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  user_id uuid references users(id) on delete cascade not null,
  post_id bigint references posts(id) on delete cascade not null,
  is_favorite boolean default false not null,
  unique (user_id, post_id)
);

create table votes (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  user_id uuid references users(id) on delete cascade not null,
  post_id bigint references posts(id) on delete cascade not null,
  is_like smallint default 0 not null,
  is_dislike smallint default 0 not null,
  unique (user_id, post_id)
);

create table tags (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  user_id uuid references users(id) on delete cascade not null,
  name text,
  slug text,
  description text
);

create table tagmeta (
  id bigint generated by default as identity primary key,
  tag_id bigint references tags(id) on delete cascade not null,
  meta_key varchar(255) not null,
  meta_value text,
  unique (tag_id, meta_key)
);

create table post_tags (
  id bigint generated by default as identity primary key,
  user_id uuid references users(id) on delete cascade not null,
  post_id bigint references posts(id) on delete cascade not null,
  tag_id bigint references tags(id) on delete cascade not null,
  unique (user_id, post_id, tag_id)
);

create table statistics (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  visitor_id uuid not null,
  user_id uuid references users(id) on delete cascade,
  title text,
  location text,
  path text,
  query text,
  referrer text,
  ip inet,
  browser jsonb,
  user_agent text
);

create table usermeta (
  id bigint generated by default as identity primary key,
  user_id uuid references users(id) on delete cascade not null,
  meta_key varchar(255) not null,
  meta_value text,
  unique(user_id, meta_key)
);

create index usermeta_user_id_idx on usermeta (user_id);
create index usermeta_meta_key_idx on usermeta (meta_key);

-- Create indexes
create index users_username_idx on users (username);
create index users_role_idx on users (role);
create index users_plan_idx on users (plan);

create index emails_user_id_idx on emails (user_id);
create index emails_email_idx on emails (email);

create index notifications_user_id_idx on notifications (user_id);

create index posts_slug_idx on posts (slug);
create index posts_type_status_date_idx on posts (type, status, date, id);
create index posts_user_id_idx on posts (user_id);
create index posts_user_id_slug_idx on posts (user_id, slug);

create index postmeta_post_id_idx on postmeta (post_id);
create index postmeta_meta_key_idx on postmeta (meta_key);

create index favorites_user_id_idx on favorites (user_id);
create index favorites_post_id_idx on favorites (post_id);

create index votes_user_id_idx on votes (user_id);
create index votes_post_id_idx on votes (post_id);

create index tags_name_idx on tags (name);
create index tags_slug_idx on tags (slug);
create index tags_user_id_idx on tags (user_id);
create index tags_user_id_name_idx on tags (user_id, name);
create index tags_user_id_slug_idx on tags (user_id, slug);

create index tagmeta_tag_id_idx on tagmeta (tag_id);
create index tagmeta_meta_key_idx on tagmeta (meta_key);

create index post_tags_user_id_idx on post_tags (user_id);
create index post_tags_post_id_idx on post_tags (post_id);
create index post_tags_tag_id_idx on post_tags (tag_id);
create index post_tags_user_id_post_id_idx on post_tags (user_id, post_id);

create index statistics_visitor_id_idx on statistics (visitor_id);
create index statistics_user_id_idx on statistics (user_id);

-- User related functions


create or replace function generate_password()
returns text
security definer set search_path = public
as $$
begin
  return trim(both from (encode(decode(md5(random()::text || current_timestamp || random()),'hex'),'base64')), '=');
end;
$$ language plpgsql;

create or replace function generate_username(email text)
returns text
security definer set search_path = public
as $$
declare
  new_username text;
  username_exists boolean;
begin
  new_username := lower(split_part(email, '@', 1));
  select exists(select 1 from users where username = new_username) into username_exists;

  while username_exists loop
    new_username := new_username || '_' || to_char(trunc(random()*1000000), 'fm000000');
    select exists(select 1 from users where username = new_username) into username_exists;
  end loop;

  return new_username;
end;
$$ language plpgsql;

create or replace function verify_user_password(userid uuid, password text)
returns boolean
security definer set search_path = public, extensions, auth
as $$
begin
  return exists (
    select id
    from auth.users
    where id = userid
      and encrypted_password = crypt(password::text, auth.users.encrypted_password)
  );
end;
$$ language plpgsql;

create or replace function create_new_user(useremail text, password text = null, metadata JSONB = '{}'::JSONB)
returns uuid
as $$
declare
  user_id uuid;
  encrypted_pw text;
  app_metadata jsonb;
begin
  select id into user_id from auth.users where email = useremail;

  if user_id is null then
    user_id := gen_random_uuid();
    encrypted_pw := crypt(password, gen_salt('bf'));
    app_metadata := '{"provider":"email","providers":["email"]}'::jsonb || metadata::jsonb;

    insert into auth.users
    (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, recovery_sent_at, last_sign_in_at, confirmation_sent_at, raw_app_meta_data, raw_user_meta_data, created_at, updated_at, confirmation_token, email_change, email_change_token_new, recovery_token)
    values
    ('00000000-0000-0000-0000-000000000000', user_id, 'authenticated', 'authenticated', useremail, encrypted_pw, now(), now(), now(), now(), app_metadata, '{}', now(), now(), '', '', '', '');

    insert into auth.identities
    (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at)
    values
    (gen_random_uuid(), user_id, format('{"sub":"%s","email":"%s"}', user_id::text, useremail)::jsonb, 'email', now(), now(), now());
  end if;

  return user_id;
end;
$$ language plpgsql;

create or replace function delete_user(useremail text)
returns void
as $$
begin
  if exists (select 1 from auth.users where email = useremail) then
    delete from auth.users where email = useremail;
  end if;
end;
$$ language plpgsql;

create or replace function handle_new_user()
returns trigger
security definer set search_path = public
as $$
declare
  new_username text;
  new_has_set_password boolean;
begin
  new_username := generate_username(new.email);
  new_username := substr(new_username, 1, 255);
  new_has_set_password := case when new.encrypted_password is null or new.encrypted_password = '' then false else true end;

  insert into users
  (id, has_set_password, username, full_name, avatar_url)
  values
  (new.id, new_has_set_password, new_username, new_username, new.raw_user_meta_data ->> 'avatar_url');
  insert into emails (user_id, email) values (new.id, new.email);
  insert into notifications (user_id) values (new.id);

  return new;
end;
$$ language plpgsql;

create or replace function assign_user_data()
returns void
security definer set search_path = public
as $$
declare
  r record;
  new_username text;
  new_has_set_password boolean;
begin
  for r in (select * from auth.users) loop
    if not exists (select 1 from users where id = r.id) then
      new_username := generate_username(r.email);
      new_username := substr(new_username, 1, 255);
      new_has_set_password := case when r.encrypted_password is null or r.encrypted_password = '' then false else true end;
      insert into users (id, has_set_password, username, full_name, avatar_url) values (r.id, new_has_set_password, new_username, new_username, r.raw_user_meta_data ->> 'avatar_url');
      insert into emails (user_id, email) values (r.id, r.email);
      insert into notifications (user_id) values (r.id);
    end if;
  end loop;
end;
$$ language plpgsql;

create or replace function handle_username_changed_at()
returns trigger
security definer set search_path = public
as $$
begin
  update users set username_changed_at = now() where id = new.id;

  update posts
  set permalink = replace(permalink, old.username, new.username)
  where user_id = new.id and permalink like '%/'|| old.username ||'/%';

  update statistics
  set path = replace(path, old.username, new.username),
      location = replace(location, old.username, new.username),
      referrer = replace(referrer, old.username, new.username)
  where path like '/'|| old.username ||'/%';

  return new;
end;
$$ language plpgsql;

create or replace function handle_role_changed_at()
returns trigger
security definer set search_path = public
as $$
begin
  update users set role_changed_at = now() where id = new.id;
  return new;
end;
$$ language plpgsql;

create or replace function handle_plan_changed_at()
returns trigger
security definer set search_path = public
as $$
begin
  update users set plan_changed_at = now() where id = new.id;
  return new;
end;
$$ language plpgsql;

create or replace function handle_has_set_password()
returns trigger
security definer set search_path = public
as $$
declare
  new_has_set_password boolean;
begin
  new_has_set_password := case when (new.encrypted_password is null or new.encrypted_password = '') then false else true end;
  update users set has_set_password = new_has_set_password where id = new.id;
  return new;
end;
$$ language plpgsql;

create or replace function set_user_role(userrole text, userid uuid = null, useremail text = null)
returns void
security definer set search_path = public
as $$
begin
  if userid is not null and useremail is not null then
    update users u set role = userrole from auth.users au where au.id = u.id and au.id = userid and au.email = useremail;
  elsif userid is not null then
    update users u set role = userrole from auth.users au where au.id = u.id and au.id = userid;
  elsif useremail is not null then
    update users u set role = userrole from auth.users au where au.id = u.id and au.email = useremail;
  end if;
end;
$$ language plpgsql;

create or replace function set_user_plan(userplan text, userid uuid = null, useremail text = null)
returns void
security definer set search_path = public
as $$
begin
  if userid is not null and useremail is not null then
    update users u set plan = userplan from auth.users au where au.id = u.id and au.id = userid and au.email = useremail;
  elsif userid is not null then
    update users u set plan = userplan from auth.users au where au.id = u.id and au.id = userid;
  elsif useremail is not null then
    update users u set plan = userplan from auth.users au where au.id = u.id and au.email = useremail;
  end if;
end;
$$ language plpgsql;

create or replace function set_user_meta(userid bigint, metakey text, metavalue text = null)
returns void
security definer set search_path = public
as $$
begin
  if exists (select 1 from usermeta where user_id = userid and meta_key = metakey) then
    update usermeta set meta_value = metavalue where user_id = userid and meta_key = metakey;
  else
    insert into usermeta(user_id, meta_key, meta_value) values(userid, metakey, metavalue);
  end if;
end;
$$ language plpgsql;

create or replace function get_users(userrole text = null, userplan text = null)
returns setof users
security definer set search_path = public
as $$
begin
  if userrole is not null and userplan is not null then
    return query
    select * from users where role = userrole and plan = userplan;
  elsif userrole is not null then
    return query
    select * from users where role = userrole;
  elsif userplan is not null then
    return query
    select * from users where plan = userplan;
  end if;
end;
$$ language plpgsql;

-- Posts related functions
create or replace function unique_post_slug()
returns trigger
security definer set search_path = public
as $$
declare
  old_slug text;
  new_slug text;
  slug_exists boolean;
  counter integer := 1;
  old_permalink text;
begin
  old_slug := new.slug;
  new_slug := old_slug;
  old_permalink := new.permalink;

  select exists(select 1 from posts where user_id = new.user_id and slug = new_slug and id != coalesce(new.id, 0)) into slug_exists;

  while slug_exists loop
    new_slug := old_slug || '-' || counter;
    counter := counter + 1;
    select exists(select 1 from posts where user_id = new.user_id and slug = new_slug and id != coalesce(new.id, 0)) into slug_exists;
  end loop;

  new.slug := new_slug;
  new.permalink := replace(old_permalink, old_slug, new_slug);
  return new;
end;
$$ language plpgsql;

create or replace function generate_post_slug(userid uuid, postslug text)
returns text
security definer set search_path = public
as $$
declare
  old_slug text;
  new_slug text;
  slug_exists boolean;
  counter integer := 1;
begin
  old_slug := postslug;
  new_slug := old_slug;

  select exists(select 1 from posts where user_id = userid and slug = new_slug) into slug_exists;

  while slug_exists loop
    new_slug := old_slug || '-' || counter;
    counter := counter + 1;
    select exists(select 1 from posts where user_id = userid and slug = new_slug) into slug_exists;
  end loop;

  return new_slug;
end;
$$ language plpgsql;

create or replace function set_post_meta(postid bigint, metakey text, metavalue text = null)
returns void
security definer set search_path = public
as $$
begin
  if exists (select 1 from postmeta where post_id = postid and meta_key = metakey) then
    update postmeta set meta_value = metavalue where post_id = postid and meta_key = metakey;
  else
    insert into postmeta(post_id, meta_key, meta_value) values(postid, metakey, metavalue);
  end if;
end;
$$ language plpgsql;

create or replace function set_post_views(postid bigint)
returns void
security definer set search_path = public
as $$
begin
  if exists (select 1 from postmeta where post_id = postid and meta_key = 'views') then
    update postmeta set meta_value = meta_value::integer + 1 where post_id = postid and meta_key = 'views';
  else
    insert into postmeta(post_id, meta_key, meta_value) values(postid, 'views', '1');
  end if;
end;
$$ language plpgsql;

create or replace function count_posts(
  userid uuid,
  posttype text = 'post',
  q text = null
)
returns table(status text, count bigint)
security definer set search_path = public
as $$
begin
  if q is not null then
    return query
    select p.status, count(*)
    from posts p
    where p.user_id = userid and p.type = posttype and to_tsvector(title) @@ to_tsquery(q)
    group by p.status;
  else
    return query
    select p.status, count(*)
    from posts p
    where p.user_id = userid and p.type = posttype
    group by p.status;
  end if;
end;
$$ language plpgsql;

create or replace function get_adjacent_post_id(
  postid bigint,
  userid uuid,
  posttype text = 'post',
  poststatus text = 'publish'
)
returns table(previous_id bigint, next_id bigint)
security definer set search_path = public
as $$
begin
  return query
  select max(case when id < postid then id end), min(case when id > postid then id end)
  from posts
  where user_id = userid and type = posttype and status = poststatus;
end;
$$ language plpgsql;

create or replace function create_new_posts(data json[])
returns void
security definer set search_path = public
as $$
declare
  r json;
  postid bigint;
begin
  foreach r in array data loop
    insert into posts
    (created_at, updated_at, deleted_at, date, user_id, type, status, password, title, slug, description, keywords, content, thumbnail_url, permalink, is_ban, banned_until)
    values
    (
      coalesce((r ->> 'created_at')::timestamptz, now()),
      coalesce((r ->> 'updated_at')::timestamptz, now()),
      (r ->> 'deleted_at')::timestamptz,
      (r ->> 'date')::timestamptz,
      (r ->> 'user_id')::uuid,
      coalesce((r ->> 'type')::text, 'post'),
      coalesce((r ->> 'status')::text, 'draft'),
      (r ->> 'password')::varchar(255),
      (r ->> 'title')::text,
      (r ->> 'slug')::text,
      (r ->> 'description')::text,
      (r ->> 'keywords')::text,
      (r ->> 'content')::text,
      (r ->> 'thumbnail_url')::text,
      (r ->> 'permalink')::text,
      coalesce((r ->> 'is_ban')::boolean, false),
      (r ->> 'banned_until')::timestamptz
    );
  end loop;
end;
$$ language plpgsql;


create or replace function handle_new_post()
returns trigger
security definer set search_path = public
as $$
begin
  insert into postmeta (post_id, meta_key, meta_value) values (new.id, 'views', '0');
  return new;
end;
$$ language plpgsql;

-- Handle new post function
create or replace function handle_new_post()
returns trigger
security definer set search_path = public
as $$
begin
  insert into postmeta (post_id, meta_key, meta_value) values (new.id, 'views', '0');
  return new;
end;
$$ language plpgsql;

-- Tag slug functions
create or replace function unique_tag_slug()
returns trigger
security definer set search_path = public
as $$
declare
  old_slug text;
  new_slug text;
  slug_exists boolean;
  counter integer := 1;
begin
  old_slug := new.slug;
  new_slug := old_slug;

  select exists(select 1 from tags where user_id = new.user_id and slug = new_slug and id != coalesce(new.id, 0)) into slug_exists;

  while slug_exists loop
    new_slug := old_slug || '-' || counter;
    counter := counter + 1;
    select exists(select 1 from tags where user_id = new.user_id and slug = new_slug and id != coalesce(new.id, 0)) into slug_exists;
  end loop;

  new.slug := new_slug;
  return new;
end;
$$ language plpgsql;

-- Post and Tag text search functions
create or replace function title_description(posts)
returns text
as $$
  select $1.title || ' ' || $1.description;
$$ language sql immutable;

create or replace function title_keywords(posts)
returns text
as $$
  select $1.title || ' ' || $1.keywords;
$$ language sql immutable;

create or replace function title_content(posts)
returns text
as $$
  select $1.title || ' ' || $1.content;
$$ language sql immutable;

create or replace function title_description_keywords(posts)
returns text
as $$
  select $1.title || ' ' || $1.description || ' ' || $1.keywords;
$$ language sql immutable;

create or replace function title_description_content(posts)
returns text
as $$
  select $1.title || ' ' || $1.description || ' ' || $1.content;
$$ language sql immutable;

-- Job scheduling functions
create or replace function hourly_publish_future_posts()
returns void
security definer set search_path = public
as $$
declare
  r record;
  visibility text;
begin
  for r in (select * from posts where status = 'future' and date < now()) loop
    select meta_value into visibility from postmeta where post_id = r.id and meta_key = 'visibility';

    if visibility = 'private' then
      update posts set status = 'private' where id = r.id;
    else
      update posts set status = 'publish' where id = r.id;
    end if;

    update postmeta set meta_value = null where post_id = r.id and meta_key = 'future_date';
  end loop;
end;
$$ language plpgsql;

create or replace function daily_delete_old_cron_job_run_details()
returns void
security definer set search_path = public
as $$
begin
  delete from cron.job_run_details where start_time < now() - interval '30 days';
end;
$$ language plpgsql;

-- Statistics functions
create or replace function set_statistics(data json)
returns void
security definer set search_path = public
as $$
begin
  insert into statistics
  (visitor_id,user_id,title,location,path,query,referrer,ip,browser,user_agent)
  values
  (
    (data ->> 'visitor_id')::uuid,
    coalesce((data ->> 'user_id')::uuid, null),
    (data ->> 'title')::text,
    (data ->> 'location')::text,
    (data ->> 'path')::text,
    (data ->> 'query')::text,
    (data ->> 'referrer')::text,
    (data ->> 'ip')::inet,
    (data ->> 'browser')::jsonb,
    (data ->> 'user_agent')::text
  );
end;
$$ language plpgsql;

create or replace function truncate_statistics()
returns void
security definer set search_path = public
as $$
begin
  truncate table statistics restart identity cascade;
end;
$$ language plpgsql;

-- Post rank function
create or replace function get_post_rank_by_views(
  username text,
  q text = '',
  order_by text = 'views',
  ascending boolean = true,
  per_page integer = 10,
  page integer = 1,
  head boolean = false
)
returns table(path text, title text, views bigint)
security definer set search_path = public
as $$
declare
  _command text;
  _order text;
  _offset integer;
begin
  _order := case when ascending is false then 'desc' else 'asc' end;
  _offset := (page - 1) * per_page;

  if q <> '' then
    if head then
      _command := 'select s.path, s.title, count(*) as views
      from statistics s
      where s.path like ''/'|| username ||'/%%''
        and s.path not like ''/'|| username ||'/favorites''
        and s.title ilike ''%%'|| q ||'%%''
      group by s.path, s.title ';
      return query execute format(_command) using username, q;
    else
      _command := 'select s.path, s.title, count(*) as views
      from statistics s
      where s.path like ''/'|| username ||'/%%''
        and s.path not like ''/'|| username ||'/favorites''
        and s.title ilike ''%%'|| q ||'%%''
      group by s.path, s.title
      order by %I %s limit %s offset %s ';
      return query execute format(_command, order_by, _order, per_page, _offset) using username, q;
    end if;
  else
    if head then
      _command := 'select s.path, s.title, count(*) as views
      from statistics s
      where s.path like ''/'|| username ||'/%%''
        and s.path not like ''/'|| username ||'/favorites''
      group by s.path, s.title ';
      return query execute format(_command) using username;
    else
      _command := 'select s.path, s.title, count(*) as views
      from statistics s
      where s.path like ''/'|| username ||'/%%''
        and s.path not like ''/'|| username ||'/favorites''
      group by s.path, s.title
      order by %I %s limit %s offset %s ';
      return query execute format(_command, order_by, _order, per_page, _offset) using username;
    end if;
  end if;
end;
$$ language plpgsql;

-- Drop existing triggers first to avoid conflicts
drop trigger if exists on_created on auth.users;
drop trigger if exists on_encrypted_password_updated on auth.users;
drop trigger if exists on_updated_at on users;
drop trigger if exists on_username_updated on users;
drop trigger if exists on_role_updated on users;
drop trigger if exists on_plan_updated on users;
drop trigger if exists on_updated_at on role_permissions;
drop trigger if exists on_updated_at on users;
drop trigger if exists on_updated_at on emails;
drop trigger if exists on_updated_at on notifications;
drop trigger if exists on_updated_at on votes;
drop trigger if exists on_updated_at on favorites;
drop trigger if exists on_slug_upsert on posts;
drop trigger if exists on_updated_at on posts;
drop trigger if exists on_created on posts;
drop trigger if exists on_updated_at on tags;
drop trigger if exists on_slug_upsert on tags;

-- Create triggers for auth.users
create trigger on_encrypted_password_updated 
  after update of encrypted_password on auth.users
  for each row execute function handle_has_set_password();

create trigger on_created 
  after insert on auth.users
  for each row execute procedure handle_new_user();

-- Create triggers for users table
create trigger on_updated_at 
  before update on users
  for each row execute procedure moddatetime (updated_at);

create trigger on_username_updated 
  after update of username on users
  for each row execute function handle_username_changed_at();

create trigger on_role_updated 
  after update of role on users
  for each row execute function handle_role_changed_at();

create trigger on_plan_updated 
  after update of plan on users
  for each row execute function handle_plan_changed_at();

-- Create triggers for emails table
create trigger on_updated_at 
  before update on emails
  for each row execute procedure moddatetime (updated_at);

-- Create triggers for notifications table
create trigger on_updated_at 
  before update on notifications
  for each row execute procedure moddatetime (updated_at);

-- Create triggers for posts table
create trigger on_updated_at 
  before update on posts
  for each row execute procedure moddatetime (updated_at);

create trigger on_slug_upsert 
  before insert or update of slug on posts
  for each row execute function unique_post_slug();

create trigger on_created 
  after insert on posts
  for each row execute procedure handle_new_post();

-- Create triggers for favorites table
create trigger on_updated_at 
  before update on favorites
  for each row execute procedure moddatetime (updated_at);

-- Create triggers for votes table
create trigger on_updated_at 
  before update on votes
  for each row execute procedure moddatetime (updated_at);

-- Create triggers for tags table
create trigger on_updated_at 
  before update on tags
  for each row execute procedure moddatetime (updated_at);

create trigger on_slug_upsert 
  before insert or update of slug on tags
  for each row execute function unique_tag_slug();


-- Enable RLS for all tables
alter table users enable row level security;
alter table role_permissions enable row level security;
alter table emails enable row level security;
alter table notifications enable row level security;
alter table posts enable row level security;
alter table postmeta enable row level security;
alter table favorites enable row level security;
alter table votes enable row level security;
alter table tags enable row level security;
alter table tagmeta enable row level security;
alter table post_tags enable row level security;
alter table statistics enable row level security;
alter table usermeta enable row level security;

-- Users policies
create policy "Public access for all users" on users 
  for select to authenticated, anon using ( true );
create policy "User can insert their own users" on users 
  for insert to authenticated with check ( (select auth.uid()) = id );
create policy "User can update their own users" on users 
  for update to authenticated using ( (select auth.uid()) = id );
create policy "User can delete their own users" on users 
  for delete to authenticated using ( (select auth.uid()) = id );

-- Role permissions policies
create policy "Public access for all users" on role_permissions 
  for select to authenticated, anon using ( true );
create policy "User can insert role_permissions" on role_permissions 
  for insert to authenticated with check ( true );
create policy "User can update role_permissions" on role_permissions 
  for update to authenticated using ( true );
create policy "User can delete role_permissions" on role_permissions 
  for delete to authenticated using ( true );

-- Emails policies
create policy "User can select their own emails" on emails 
  for select to authenticated using ( (select auth.uid()) = user_id );
create policy "User can insert their own emails" on emails 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own emails" on emails 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own emails" on emails 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Notifications policies
create policy "User can select their own notifications" on notifications 
  for select to authenticated using ( (select auth.uid()) = user_id );
create policy "User can insert their own notifications" on notifications 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own notifications" on notifications 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own notifications" on notifications 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Posts policies
create policy "Public access for all users" on posts 
  for select to authenticated, anon using ( true );
create policy "User can insert their own posts" on posts 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own posts" on posts 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own posts" on posts 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Postmeta policies
create policy "Public access for all users" on postmeta 
  for select to authenticated, anon using ( true );
create policy "User can insert postmeta" on postmeta 
  for insert to authenticated with check ( true );
create policy "User can update postmeta" on postmeta 
  for update to authenticated using ( true );
create policy "User can delete postmeta" on postmeta 
  for delete to authenticated using ( true );

-- Favorites policies
create policy "Public access for all users" on favorites 
  for select to authenticated, anon using ( true );
create policy "User can insert their own favorites" on favorites 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own favorites" on favorites 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own favorites" on favorites 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Votes policies
create policy "Public access for all users" on votes 
  for select to authenticated, anon using ( true );
create policy "User can insert their own votes" on votes 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own votes" on votes 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own votes" on votes 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Tags policies
create policy "Public access for all users" on tags 
  for select to authenticated, anon using ( true );
create policy "User can insert their own tags" on tags 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own tags" on tags 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own tags" on tags 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Tagmeta policies
create policy "Public access for all users" on tagmeta 
  for select to authenticated, anon using ( true );
create policy "User can insert tagmeta" on tagmeta 
  for insert to authenticated with check ( true );
create policy "User can update tagmeta" on tagmeta 
  for update to authenticated using ( true );
create policy "User can delete tagmeta" on tagmeta 
  for delete to authenticated using ( true );

-- Post tags policies
create policy "Public access for all users" on post_tags 
  for select to authenticated, anon using ( true );
create policy "User can insert their own post_tags" on post_tags 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own post_tags" on post_tags 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own post_tags" on post_tags 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Statistics policies
create policy "Public access for all users" on statistics 
  for select to authenticated, anon using ( true );
create policy "User can insert statistics" on statistics 
  for insert to authenticated with check ( true );
create policy "User can update statistics" on statistics 
  for update to authenticated using ( true );
create policy "User can delete statistics" on statistics 
  for delete to authenticated using ( true );

-- Usermeta policies
create policy "Public access for all users" on usermeta 
  for select to authenticated, anon using ( true );
create policy "User can insert their own usermeta" on usermeta 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own usermeta" on usermeta 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own usermeta" on usermeta 
  for delete to authenticated using ( (select auth.uid()) = user_id );


-- Enable RLS for all tables
alter table users enable row level security;
alter table role_permissions enable row level security;
alter table emails enable row level security;
alter table notifications enable row level security;
alter table posts enable row level security;
alter table postmeta enable row level security;
alter table favorites enable row level security;
alter table votes enable row level security;
alter table tags enable row level security;
alter table tagmeta enable row level security;
alter table post_tags enable row level security;
alter table statistics enable row level security;
alter table usermeta enable row level security;

-- Users policies
create policy "Public access for all users" on users 
  for select to authenticated, anon using ( true );
create policy "User can insert their own users" on users 
  for insert to authenticated with check ( (select auth.uid()) = id );
create policy "User can update their own users" on users 
  for update to authenticated using ( (select auth.uid()) = id );
create policy "User can delete their own users" on users 
  for delete to authenticated using ( (select auth.uid()) = id );

-- Role permissions policies
create policy "Public access for all users" on role_permissions 
  for select to authenticated, anon using ( true );
create policy "User can insert role_permissions" on role_permissions 
  for insert to authenticated with check ( true );
create policy "User can update role_permissions" on role_permissions 
  for update to authenticated using ( true );
create policy "User can delete role_permissions" on role_permissions 
  for delete to authenticated using ( true );

-- Emails policies
create policy "User can select their own emails" on emails 
  for select to authenticated using ( (select auth.uid()) = user_id );
create policy "User can insert their own emails" on emails 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own emails" on emails 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own emails" on emails 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Notifications policies
create policy "User can select their own notifications" on notifications 
  for select to authenticated using ( (select auth.uid()) = user_id );
create policy "User can insert their own notifications" on notifications 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own notifications" on notifications 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own notifications" on notifications 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Posts policies
create policy "Public access for all users" on posts 
  for select to authenticated, anon using ( true );
create policy "User can insert their own posts" on posts 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own posts" on posts 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own posts" on posts 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Postmeta policies
create policy "Public access for all users" on postmeta 
  for select to authenticated, anon using ( true );
create policy "User can insert postmeta" on postmeta 
  for insert to authenticated with check ( true );
create policy "User can update postmeta" on postmeta 
  for update to authenticated using ( true );
create policy "User can delete postmeta" on postmeta 
  for delete to authenticated using ( true );

-- Favorites policies
create policy "Public access for all users" on favorites 
  for select to authenticated, anon using ( true );
create policy "User can insert their own favorites" on favorites 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own favorites" on favorites 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own favorites" on favorites 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Votes policies
create policy "Public access for all users" on votes 
  for select to authenticated, anon using ( true );
create policy "User can insert their own votes" on votes 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own votes" on votes 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own votes" on votes 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Tags policies
create policy "Public access for all users" on tags 
  for select to authenticated, anon using ( true );
create policy "User can insert their own tags" on tags 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own tags" on tags 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own tags" on tags 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Tagmeta policies
create policy "Public access for all users" on tagmeta 
  for select to authenticated, anon using ( true );
create policy "User can insert tagmeta" on tagmeta 
  for insert to authenticated with check ( true );
create policy "User can update tagmeta" on tagmeta 
  for update to authenticated using ( true );
create policy "User can delete tagmeta" on tagmeta 
  for delete to authenticated using ( true );

-- Post tags policies
create policy "Public access for all users" on post_tags 
  for select to authenticated, anon using ( true );
create policy "User can insert their own post_tags" on post_tags 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own post_tags" on post_tags 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own post_tags" on post_tags 
  for delete to authenticated using ( (select auth.uid()) = user_id );

-- Statistics policies
create policy "Public access for all users" on statistics 
  for select to authenticated, anon using ( true );
create policy "User can insert statistics" on statistics 
  for insert to authenticated with check ( true );
create policy "User can update statistics" on statistics 
  for update to authenticated using ( true );
create policy "User can delete statistics" on statistics 
  for delete to authenticated using ( true );

-- Usermeta policies
create policy "Public access for all users" on usermeta 
  for select to authenticated, anon using ( true );
create policy "User can insert their own usermeta" on usermeta 
  for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "User can update their own usermeta" on usermeta 
  for update to authenticated using ( (select auth.uid()) = user_id );
create policy "User can delete their own usermeta" on usermeta 
  for delete to authenticated using ( (select auth.uid()) = user_id );